{"ast":null,"code":"// src/lib/supabase.js\n// This file handles all database operations\n\nimport { createClient } from '@supabase/supabase-js';\nconst supabaseUrl = process.env.REACT_APP_SUPABASE_URL;\nconst supabaseAnonKey = process.env.REACT_APP_SUPABASE_ANON_KEY;\n\n// Create Supabase client\nexport const supabase = createClient(supabaseUrl, supabaseAnonKey, {\n  auth: {\n    persistSession: true,\n    autoRefreshToken: true,\n    detectSessionInUrl: true,\n    flowType: 'pkce',\n    lock: false // DISABLE auth lock to prevent timeout errors\n  }\n});\n\n// Database helper functions\nexport const db = {\n  // Get therapist by custom URL (for client intake)\n  async getTherapistByUrl(customUrl) {\n    const {\n      data,\n      error\n    } = await supabase.from('therapists').select('id, business_name, full_name').eq('custom_url', customUrl).single();\n    if (error) throw error;\n    return data;\n  },\n  // Create or update client\n  async upsertClient(therapistId, clientData) {\n    // Check if client exists by phone\n    const {\n      data: existing\n    } = await supabase.from('clients').select('*').eq('therapist_id', therapistId).eq('phone', clientData.phone).maybeSingle();\n    if (existing) return existing;\n\n    // Create new client\n    const {\n      data,\n      error\n    } = await supabase.from('clients').insert([{\n      therapist_id: therapistId,\n      name: clientData.name,\n      phone: clientData.phone,\n      email: clientData.email || null\n    }]).select().single();\n    if (error) throw error;\n    return data;\n  },\n  // Create session (client intake submission)\n  async createSession(sessionData) {\n    const {\n      data,\n      error\n    } = await supabase.from('sessions').insert([sessionData]).select().single();\n    if (error) throw error;\n    return data;\n  },\n  // Get all sessions for a therapist\n  async getTherapistSessions(therapistId) {\n    const {\n      data,\n      error\n    } = await supabase.from('sessions').select(`\n        *,\n        client:clients(*)\n      `).eq('therapist_id', therapistId).order('created_at', {\n      ascending: false\n    }).limit(100);\n    if (error) throw error;\n    return data;\n  },\n  // Get single session details\n  async getSession(sessionId) {\n    const {\n      data,\n      error\n    } = await supabase.from('sessions').select(`\n        *,\n        client:clients(*)\n      `).eq('id', sessionId).single();\n    if (error) throw error;\n    return data;\n  },\n  // Update session (add notes, mark complete)\n  async updateSession(sessionId, updates) {\n    const {\n      data,\n      error\n    } = await supabase.from('sessions').update(updates).eq('id', sessionId).select().single();\n    if (error) throw error;\n    return data;\n  },\n  // Mark session as complete\n  async completeSession(sessionId, therapistNotes) {\n    const {\n      data,\n      error\n    } = await supabase.from('sessions').update({\n      completed: true,\n      completed_at: new Date().toISOString(),\n      therapist_notes: therapistNotes\n    }).eq('id', sessionId).select().single();\n    if (error) throw error;\n    return data;\n  },\n  // Get all clients for therapist\n  async getTherapistClients(therapistId) {\n    const {\n      data,\n      error\n    } = await supabase.from('clients').select('*').eq('therapist_id', therapistId).order('created_at', {\n      ascending: false\n    });\n    if (error) throw error;\n    return data;\n  },\n  // Get client history\n  async getClientHistory(clientId) {\n    const {\n      data,\n      error\n    } = await supabase.from('sessions').select('*').eq('client_id', clientId).order('created_at', {\n      ascending: false\n    });\n    if (error) throw error;\n    return data;\n  }\n};","map":{"version":3,"names":["createClient","supabaseUrl","process","env","REACT_APP_SUPABASE_URL","supabaseAnonKey","REACT_APP_SUPABASE_ANON_KEY","supabase","auth","persistSession","autoRefreshToken","detectSessionInUrl","flowType","lock","db","getTherapistByUrl","customUrl","data","error","from","select","eq","single","upsertClient","therapistId","clientData","existing","phone","maybeSingle","insert","therapist_id","name","email","createSession","sessionData","getTherapistSessions","order","ascending","limit","getSession","sessionId","updateSession","updates","update","completeSession","therapistNotes","completed","completed_at","Date","toISOString","therapist_notes","getTherapistClients","getClientHistory","clientId"],"sources":["/Users/harshkumar/Library/CloudStorage/OneDrive-IBM/X HK HK Psnl/00 A Personal/01 Ideas/BodyMap/Product/bodymap-final/src/lib/supabase.js"],"sourcesContent":["// src/lib/supabase.js\n// This file handles all database operations\n\nimport { createClient } from '@supabase/supabase-js';\n\nconst supabaseUrl = process.env.REACT_APP_SUPABASE_URL;\nconst supabaseAnonKey = process.env.REACT_APP_SUPABASE_ANON_KEY;\n\n// Create Supabase client\nexport const supabase = createClient(supabaseUrl, supabaseAnonKey, {\n  auth: {\n    persistSession: true,\n    autoRefreshToken: true,\n    detectSessionInUrl: true,\n    flowType: 'pkce',\n    lock: false  // DISABLE auth lock to prevent timeout errors\n  }\n});\n\n// Database helper functions\nexport const db = {\n  // Get therapist by custom URL (for client intake)\n  async getTherapistByUrl(customUrl) {\n    const { data, error } = await supabase\n      .from('therapists')\n      .select('id, business_name, full_name')\n      .eq('custom_url', customUrl)\n      .single();\n    \n    if (error) throw error;\n    return data;\n  },\n\n  // Create or update client\n  async upsertClient(therapistId, clientData) {\n    // Check if client exists by phone\n    const { data: existing } = await supabase\n      .from('clients')\n      .select('*')\n      .eq('therapist_id', therapistId)\n      .eq('phone', clientData.phone)\n      .maybeSingle();\n    \n    if (existing) return existing;\n\n    // Create new client\n    const { data, error } = await supabase\n      .from('clients')\n      .insert([{\n        therapist_id: therapistId,\n        name: clientData.name,\n        phone: clientData.phone,\n        email: clientData.email || null\n      }])\n      .select()\n      .single();\n    \n    if (error) throw error;\n    return data;\n  },\n\n  // Create session (client intake submission)\n  async createSession(sessionData) {\n    const { data, error } = await supabase\n      .from('sessions')\n      .insert([sessionData])\n      .select()\n      .single();\n    \n    if (error) throw error;\n    return data;\n  },\n\n  // Get all sessions for a therapist\n  async getTherapistSessions(therapistId) {\n    const { data, error } = await supabase\n      .from('sessions')\n      .select(`\n        *,\n        client:clients(*)\n      `)\n      .eq('therapist_id', therapistId)\n      .order('created_at', { ascending: false })\n      .limit(100);\n    \n    if (error) throw error;\n    return data;\n  },\n\n  // Get single session details\n  async getSession(sessionId) {\n    const { data, error } = await supabase\n      .from('sessions')\n      .select(`\n        *,\n        client:clients(*)\n      `)\n      .eq('id', sessionId)\n      .single();\n    \n    if (error) throw error;\n    return data;\n  },\n\n  // Update session (add notes, mark complete)\n  async updateSession(sessionId, updates) {\n    const { data, error } = await supabase\n      .from('sessions')\n      .update(updates)\n      .eq('id', sessionId)\n      .select()\n      .single();\n    \n    if (error) throw error;\n    return data;\n  },\n\n  // Mark session as complete\n  async completeSession(sessionId, therapistNotes) {\n    const { data, error } = await supabase\n      .from('sessions')\n      .update({\n        completed: true,\n        completed_at: new Date().toISOString(),\n        therapist_notes: therapistNotes\n      })\n      .eq('id', sessionId)\n      .select()\n      .single();\n    \n    if (error) throw error;\n    return data;\n  },\n\n  // Get all clients for therapist\n  async getTherapistClients(therapistId) {\n    const { data, error } = await supabase\n      .from('clients')\n      .select('*')\n      .eq('therapist_id', therapistId)\n      .order('created_at', { ascending: false });\n    \n    if (error) throw error;\n    return data;\n  },\n\n  // Get client history\n  async getClientHistory(clientId) {\n    const { data, error } = await supabase\n      .from('sessions')\n      .select('*')\n      .eq('client_id', clientId)\n      .order('created_at', { ascending: false });\n    \n    if (error) throw error;\n    return data;\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}